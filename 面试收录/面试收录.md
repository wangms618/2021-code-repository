近期笔者一直在面试，也总结了很多题型，故总结出来，希望有所帮助
# 面试总结（一）浏览器相关
## 1. http和https的区别
1. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
2. 一般而言，http协议的端口为80，https的端口为443。
3. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。


## 2. https是怎样工作的
1. 客户端使用httpsUrl去访问服务器
2. **服务器**返回网站的证书（证书中包含了**公钥**）给**客户端**
3. 客户端与服务器协商SSL链接的安全等级，也就是加密等级
4. **客户端建立会话密钥**，**使用**之前服务器返回的**公钥**来**加密会话密钥**（也就是说会话密钥是由公钥加密的），并将它传给服务器
5. 服务器通过自己的私钥解密出**被公钥加密后的会话密钥**
6. **服务器**通过**会话密钥加密**与客户端之间的通信

## 3. https的优点与缺点
1. 比http更加安全
2. 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器
3. https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。
4. SSL证书也需要钱，功能越强大的证书费用越高。 

## 4. TCP三次握手
1. 客户端向服务器发起第一次握手，**服务器**收到后**确认自己可以收到客户端传来的报文段**
2. 服务器向客户端发起第二次握手，**客户端**收到后**确认服务器可以收到自己的报文段，也确认自己可以接收到服务器传来的报文段**
3. 客户端向服务器发起第三次握手，**服务器**收到后**确认客户端可以收到自己传的报文**

## 5. 为什么TCP两次握手不行
如果不执行第三次握手，服务器就不知道客户端是否可以接收到自己传的报文，如果客户端第二次握手有较大延迟，那么当服务器接收到第二次握手时，客户端这时很有可能已经不接收服务器传送的报文了，而服务器依旧会传报文给客户端，这就造成了性能损耗，所以需要三次握手来证明客户端可以接受服务器传来的报文

## 6. TCP四次挥手

## 7. TCP和UDP的区别
1. TCP是面向连接的可靠传输，而UDP是无连接的
不可靠传输
1. TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。
2. TCP是面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。
3. TCP只能是1对1的，UDP支持1对1,1对多。
4. TCP的首部较大为20字节，而UDP只有8字节。




## 8. http2.0的新特性
1. 内容安全，使用http2.0可以避免单纯使用https的性能下降，因为http2.0是基于https的
2. 二进制格式，之前的http解析是基于文本的，http2.0将所有的传输信息分割为更小的消息和帧，对他们采用二进制格式编码
3. 多路复用，这个功能相当于是长连接的增强，每个request请求可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面，另外多路复用中也支持了流的优先级，允许客户端告诉服务器那些内容是更优先级的资源，可以优先传输
4. 头部压缩
5. 设置请求优先级
6. 服务器推送

## 9. http3.0的新特性
1. 在传输层使用udp替代了tcp
2. 实现了一套新的拥塞控制算法，彻底解决TCP中队头阻塞的问题
3. 实现了快速握手功能。由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据。
4. 集成了TLS加密功能。目前QUIC使用的是TLS1.3

## 10. 进程和线程的关系
1. 每个进程有独立的一块内存，进程之间相互独立
2. 多个线程在进程中协作完成任务
3. 一个进程由多个线程构成同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）
4. 进程是**CPU资源分配的最小单位**（是能拥有资源和独立运行的最小单位）
5. 线程是**CPU调度的最小单位**（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程），执行一串指令所需要的时间
6. 不同进程之间也可以通信，不过代价较大
7. 进程和线程是对cpu某个时间段做的事的描述

## 11. Cookie、sessionStorage、localStorage的区别
共同点：都是保存在浏览器端，并且是同源的
不同点：
1. Cookie的存储大小只有4k左右，sessionStorage、localStorage虽然也有存储大小的限制，但是比cookie大得多，可以达到5M或更大
2. cookie数据始终在同源的http请求中携带(即使不需要)，即cookie在浏览器和服务器间来回传递，sessionStorage、localStorage仅在客户端即浏览器中保存，不参与和服务器的通信
3. 数据的有效期不同  
`sessionStorage`：仅在当前的浏览器窗口关闭有效  
`localStorage`：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据  
`cookie`：只在设置的cookie过期时间之前一直有效，即使窗口和浏览器关闭
4. 作用域不同  
`sessionStorage`：不在不同的浏览器窗口中共享，即使是同一个页面  
`localStorage`：在所有同源窗口都是共享的  
`cookie`：也是在所有同源窗口中共享的
1. Cookie需要程序员自己封装，原生的cookie接口不友好；sessionStorage、localStorage可采用原生接口，亦可再次封装




## 12. js单线程有什么优势？
1. 提高效率
2. 节省运行内存
3. 减少上下文切换的时间

## 13. 如果一个页面加载很慢，你觉得是什么原因
1. 有可能是页面上的图片过多，解决应该用懒加载
2. 页面流量过大，超载了
3. http请求过多，没有合理的使用缓存，应该减少http请求

## 14. iframe是什么？有什么缺点？
定义：iframe元素会创建包含另一个文档的内联框架  
缺点：
1. 会阻塞主页面的onload事件
2. 搜索引擎无法解读这种页面，不利于SEO
3. iframe和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。

## 15. Cookie和session的区别
1. cookie数据存放在客户的浏览器上，session数据放在服务器上。
2. cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗
考虑到安全应当使用session。
3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
考虑到减轻服务器性能方面，应当使用cookie。
4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

## 16. Cookie如何防范XSS攻击
在HTTP头部上配置set-cookie  
有两个属性可以防止XSS攻击:  
httponly：这个属性可禁止JavaScript访问Cookie，故可以保护Cookie不被嵌入的恶意代码所获取  
secure - ：这个属性告诉客户端浏览器仅当在https请求时发送Cookie
> response.setHeader("Set-Cookie","cookiename=httponlyTest;Path=/ ;Domain=domainvalue;Hax-Age=seconds;HTTPOnly")

## 17. 移动端300ms延迟的原因及如何解决？
原因：由于移动端会有双击缩放的这个操作，因此浏览器在click之后要等待300ms，看用户有没有下一次点击，也就是这次操作是不是双击。
解决：
1. 禁用缩放。`<meta name="viewport" content="width=device-width, user-scalable=no">`
2. 利用FastClick，检测到touchend事件后，立刻出发模拟click事件，并且把浏览器300毫秒之后真正出发的事件给阻断掉

## 18. 介绍知道的http返回的状态码
1. 1xx:
2. 2xx:
3. 3xx:
4. 4xx:
5. 5xx:

## 19. 强缓存与协商缓存

## 20. GET和POST的区别
1. get参数通过url传递，post放在request body中。
2. get请求在url中传递的参数是有长度限制的，而post没有。
3. get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。
4. get请求只能进行url编码，而post支持多种编码方式
5. get请求会浏览器主动cache，而post支持多种编码方式。
6. get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。
7. GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。
8. GET产生一个TCP数据包；POST产生两个TCP数据包。

## 21. HTTP支持的方法
GET, POST, HEAD, OPTIONS, PUT, DELETE, TRACE, CONNECT

## 22. 在地址栏里输入一个URL,到这个页面呈现出来，中间会发生什么？
DNS解析
TCP连接
发送HTTP请求
服务器处理请求并返回HTTP报文
浏览器解析渲染页面
连接结束

## CSRF和XSS是什么？怎么防御
XSS：跨站脚本攻击
发生在目标用户的浏览器层面上的，当渲染DOM树的过程成发生了不在预期内执行的JS代码时，就发生了XSS攻击。大多数XSS攻击的主要方式是嵌入一段远程或者第三方域上的JS代码。实际上是在目标网站的作用域下执行了这段js代码。  
XSS防御的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码。也就是对提交的所有内容进行过滤，对url中的参数进行过滤，过滤掉会导致脚本执行的相关内容；然后对动态输出到页面的内容进行html编码，使脚本无法在浏览器中执行。虽然对输入过滤可以被绕过，但是也还是会拦截很大一部分的XSS攻击。  
CSRF：跨站请求伪造
在受害者访问一个网站时，其 Cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。  
防御CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。





















# CSS相关
# JS相关
# Vue框架相关