# 作用域是什么
- 作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期（和函数作用域、块级作用域相关）。通俗的理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。
## 编译原理
在传统编译语言流程中，程序的一段源代码在**执行之前**会经历三个步骤  
- 分词/词法分析
- 解析/语法分析
- 代码生成 
 
而javascirpt的引擎则要复杂的多


**<font color=red>Javascript引擎</font>**

>引擎可以跟据需要创建并储存变量

JavaScript的编译过程不是发生在构建之前的，大部分情况下，编译发生在代码执行前的几微秒。
## 理解作用域
例如一个程序`var a = 2`，执行它需要三位重要的演员：引擎、作用域、编译器，接下来我来演示一遍流程。  
- 首先，遇到var a，**编译器**会要求**作用域**在当前**作用域集合**中声明一个新的变量 a(*前提是该作用域不存在一个该名称的变量，如果有编译器会忽略新变量的声明，继续进行编译*)。  

- 其次，**编译器**会为**引擎**生成代码处理a = 2的赋值操作，引擎运行时，询问**当前作用域**是否有这个a变量，有则赋值，没有就会返回一个异常。

## 进一步了解
我们要了解，引擎是用来执行代码的，它要通过作用域协助执行一系列查找操作。但不同的查找，会影响最终的结果。  

引擎的查找其实可以分为两种，一种叫LHS查询，另一种叫RHS查询，其中“L”和“R”分别代表左侧和右侧，什么东西的左侧和右侧？是一个赋值操作的左侧和右侧。  
讲的深入一些，LHS的查询是试图找到变量的容器本身，RHS查询是查找某个变量的值，从这个角度说，RHS并非是在赋值操作右侧，更准确的来说是“**非左侧**”，即得到某某的值。
接下来我们考虑以下代码
```js
console.log(a);
```
这里a的引用是一个RHS引用，因为a需要查找并**取值**传递给console.log()。
```js
a = 2;
```
这里对a的引用是LHS引用，因为我们需要找到一个**容器a**来进行赋值
>在概念上最好将其理解为：“LHS-赋值操作的目标(变量)是谁”，以及“RHS-谁是赋值操作的源头(值)”

接下来我们考虑下面的情况
```js
function foo(a){
  var n = a;
  return a + b;
}
```
相信你很快就能得出LHS查询有3处，RHS查询有四处  
LHS(c=..;、a=2、b=..)  
RHS(foo(a..、=a、a..、..b)  
但是以下情况中,进行了多少次LHS查询，多少次RHS查询呢？
```js
function foo(a){
  console.log(a);//2
}
foo(2);
```
答案是一次LHS ，3次 RHS。

- 首先foo(..)函数调用需要对foo进行**RHS**引用得到foo的值。
- 其次，有一个隐式操作包含了一次**LHS**和一次**RHS**，这个操作发生在2被当成参数传递给f00(..)函数时，为了给参数a(隐式地)分配值，需要查询一个目标a(LHS)，然后查找需要的值(对a进行RHS引用),并将值传给console.log(..)。
- console.log(..)本身也需要一个引用才能执行，因此会对console对象进行**RHS**查询，检查得到的值中是否有一个叫做log的方法。

>注意：函数声明 `function foo(a){...`不能概念化为普通的变量声明和赋值,比如`var foo、foo = function(a){...`。 因为编译器可以在代码生成的同时处理函数声明和函数中值的定义，而不是引擎。因此，将函数声明理解成前面讨论的LHS查询和赋值的形式并不合适。
  

## 作用域嵌套
当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。  
考虑下列代码：
```js
function foo(a){
  console.log( a + b );
}
var b = 2;
foo( 2 );//4
// 对 b 的引用无法在 foo 内完成，但可以在上一级作用域中完成
```

## 异常
说了这么多，那为什么要区分LHS和RHS呢？  

因为在变量还没有声明(在任何作用域中都无法找到该变量)的情况下，引擎在所有作用域进行RHS查询会抛出ReferenceError异常，进行LHS查询全局作用域会创建一个具有该名称的变量返回给引擎，前提是程序运行在非“严格模式”下。

ES5中引入了“严格模式”，严格模式禁止自动或隐式地创建全局变量。因此，在严格模式中LHS查询失败时，引擎会返回类似的ReferenceError异常。

>其他情况： 如果RHS查询找到了一个变量，但是尝试对这个变量的值进行不合理的操作，比如对一个非函数类型的值进行函数调用，或者引用null和undefined类型的值中的属性，那么引擎就会抛出一个TypeError。

ReferenceError同作用域判别失败相关，而TypeError代表作用域判别成功，但是对结果的操作是非法或不合理的。

## 小结
作用域是一套规则，用于确定在何处以及如何查找变量(标识符)。如果查找的目的是对变量进行赋值，就会使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。  

LHS和RHS查询都会在当前执行作用域中开始，如果没有找到所需的标识符，就会向上级作用域继续查找，最后抵达全局作用域，无论找没找到都停止。



