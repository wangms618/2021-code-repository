# 函数作用域和块作用域

## 函数作用域
- 函数作用域的含义是，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实在嵌套的作用域中也可以使用）

下面我们来看一个例子
```js
function foo(a) {
  var b = 2;
  console.log(b);
  console.log(a);
  function bar() {
    var c = 3;
    console.log(a);
    console.log(b);
    console.log(c);
  }
  bar()
}
// console.log(a,b,c);//三个全部失败
// console.log(b);//b is not defined
// bar()// bar is not defined 
// foo(1)//2,1,1,2,3
```
- 通过以上结果可以得到，a,b,c，bar都在foo(..)函数里面，无法从foo(..)外部进行访问，也就是说无法从全局作用域中进行访问。但是这些标识符在foo(..)内部是可以被访问的，同样在bar(..)内部也可以访问（假设在bar内部没有同名的标识符声明）

### 函数作用域的功能
1. **隐藏内部实现**  
  - “隐藏内部实现”就是从所写的代码中挑选一个任意的片段，然后用函数声明对它进行包装，把这些代码“隐藏”起来，也就是说，这段代码的任何声明（变量或函数）都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的作用域中。
  - 如果所有变量和函数都在全局作用域中，会暴露过多的变量或函数，而这些变量或函数本该是私有的，正确的代码应该是可以阻止对这些变量或函数进行访问的。
  - 例
    ```js
    function doSomething(a) {
      b = a + doSomethingElse(a * 2);
      console.log(b * 3);
    }
    function doSomethingElse(a) {
      return a - 1;
    }
    var b;
    doSomething(2);//15
    ```
    代码片段中, b 和 doSomethingElse(..) 应该是 doSomething(..) 内部具体实现的“私有”内容。放在外部作用域对 b 和 doSomethingElse(..) 的“访问权限”不仅没有必要，还有危险。利用“隐藏内部实现”可以“合理”的将这些私有变量隐藏在 doSomething(..) 内部，例如
    ```js
    function doSomething(a) {
      function doSomethingElse(a) {
        return a - 1;
      }
      var b;
      b = a + doSomethingElse(a * 2);
      console.log(b * 3);
    }
    doSomething(2);//15
    ```

2. **规避冲突**
  - 我们先看一个例子
  ```js
  function foo() {
    function bar(a) {
      i = 3;//声明一个本地变量(var i = 3;)，即修改了for循环所属作用域中的 i 
      console.log(a + i);
    }
    for (var i = 0; i < 10; i++){
      bar(i * 2);//无限循环
    }
  }
  foo();
  ```
  1. bar(..)内部的赋值表达式 i = 3 覆盖了声明在 foo(..) 内部 for 循环中的 i ，使 i 被固定设置为3，永远满足小于10这个条件。
  2. 如果将bar(..)内`i = 3`同名变量设置为`var i = 3`或设置为`var j = 3`这样的不同名变量，就可以避免错误发生。究其原因在于，`var i = 3`会为 bar(..)作用域内声明一个本地变量。若此处本地变量名仍为 i ，则也可以叫它为“遮蔽变量”。


## 块级作用域
- 尽管函数作用域是最常见的作用域单元，但其他类型的作用域单元也是存在的，并且通过使用其他类型的作用域单元甚至可以实现维护起来更加优秀，简洁的代码。
- 在介绍块级作用域之前我们通过var 和 let 来做一个小实验  
请看以下代码  
let情况下  
  ```js
  {
    let i = 1;
  }
  console.log(i);//i is not defined
  console.log(typeof i);//undefined
  ```  
  var 情况下
  ```js
  {
    var c = 2;
  }
  console.log(c);//2
  ```

  同样是声明一个变量，并用 { } 将其放入，用let 和 var 声明的变量在 { } 之外产生的效果完全不同。 

  接下来，我们带着问题，进入块级作用域的学习。  

  《你不知道的javascript》里这样定义
  >块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏。

  我们再次考虑前面的问题，为什么 let 声明的变量i在用 { } 包裹起来之后，在全局作用域调用i会报错显示i未定义呢？
  - 原因就是i在块级作用域之中，当你在运行console.log(i)时，i已经结束了他的运行时间。  

  那么又有一个问题随之而来，为什么var定义的变量 i 成功定义了i呢？
  - 其实，let 可以理解为更完美的 var。 var 声明的变量的作用域是整个封闭函数。而let 声明的变量的作用域只是外层块，而不是整个外层函数。

  理解了上面内容后，我们通过let来理解块级作用域
  - let 关键字可以将变量绑定到所在的任意作用域中。换句话说，let为其声明的变量隐式劫持了所在的块作用域。
  
  那么块级作用域的概念及呼之欲出了，块级作用域是为了使变量的声明离使用的地方接近，最大限度的本地化，防止一个变量污染到整个函数作用域或全局作用域中。

## 如何创建一个块级作用域

  let  
  - let关键字可以将变量变动到所在任意作用域(通常是{..}内部)，换句话说，let为其声明的变量隐式的劫持了所在的作用域。

  with关键字
  - 用with从对象中创建出的作用域仅在with声明中而非外部作用域中

  try/catch
  - try/catch的catch分句会创建一个块作用域，其中声明的变量仅在catch中内部有效。




















